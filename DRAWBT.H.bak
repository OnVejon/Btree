#ifndef _DRAWBT.H
#define _DRAWBT.H

#include "bintree.h"
#include<GRAPHICS.H>
#include <stdio.h>
#include <math.h>
#include <time.h>
typedef struct
{
	BinTree bt;
	int x;
	int y;
}BTreeXY;
BTreeXY BTXY[31];
void showTraverse(BinTree bt,char key);
void DrawBT(BinTree bt);
void showLeaf(BinTree bt);
void showNode(BinTree bt,DataType,char key);
void DrawFindNode(BinTree bt);
void ShowTreeL(BinTree bt);
void ShowTreeR();

void  FilledCircle(int x,int y,DataType cc);
void  SignFilledCircle(int x,int y,DataType cc);

void CLine(int x1, int y1, int x2, int y2,int color);

void BTreeToArr(BinTree bt,BTreeXY BTXY[]);
void GetBTArrXY(BTreeXY BTXY[]);
void Delay2s();

int MAX_X,MAX_Y;/*屏幕宽度*/

int STATIC_X,STATIC_Y;/*线索化xy*/

int TRAVERSE_SIGN;/*线索化起始标记*/

char shu24S[]={
/* 以下是 '树' 的 24点阵宋体 字模，72 byte */
  0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,
  0x30,0x04,0x00,0x30,0x04,0x02,0x30,0x04,
  0x7F,0x30,0x04,0x06,0x34,0x05,0x85,0xFE,
  0x3E,0x44,0x30,0x04,0x44,0x30,0x0C,0x2C,
  0x30,0x0F,0x1B,0x30,0x0D,0x99,0xB0,0x14,
  0x99,0xB0,0x14,0x1C,0xB0,0x24,0x24,0x30,
  0x24,0x46,0x30,0x44,0x44,0x30,0x04,0x80,
  0x30,0x05,0x00,0x30,0x04,0x00,0x30,0x04,
  0x01,0xF0,0x04,0x00,0x60,0x00,0x00,0x00,
};
char kong24S[]={
/* 以下是 '空' 的 24点阵宋体 字模，72 byte */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,
  0x00,0x00,0x08,0x00,0x08,0x08,0x04,0x0F,
  0xFF,0xFE,0x18,0x00,0x08,0x18,0x40,0x10,
  0x30,0xE3,0x80,0x01,0x80,0x70,0x02,0x00,
  0x38,0x04,0x00,0x18,0x18,0x00,0x48,0x23,
  0xFF,0x80,0x00,0x18,0x00,0x00,0x18,0x00,
  0x00,0x18,0x00,0x00,0x18,0x00,0x00,0x18,
  0x00,0x00,0x18,0x00,0x00,0x18,0x08,0x1F,
  0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,
};

char jie64S[]={
/* 以下是 '结' 的 64点阵宋体 字模，512 byte */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,
  0x00,0x00,0xC0,0x00,0x00,0x70,0x00,0x00,
  0x00,0x00,0xE0,0x00,0x00,0x78,0x00,0x00,
  0x00,0x00,0xE0,0x00,0x00,0x60,0x00,0x00,
  0x00,0x01,0xE0,0x00,0x00,0x60,0x00,0x00,
  0x00,0x01,0xC0,0x00,0x00,0x60,0x00,0x00,
  0x00,0x01,0x80,0x00,0x00,0x60,0x00,0x00,
  0x00,0x03,0x80,0x00,0x00,0x60,0x00,0x00,
  0x00,0x03,0x00,0x00,0x00,0x60,0x00,0x00,
  0x00,0x07,0x00,0x00,0x00,0x60,0x00,0x00,
  0x00,0x06,0x00,0x00,0x00,0x60,0x01,0x80,
  0x00,0x0C,0x00,0x00,0x00,0x60,0x03,0xC0,
  0x00,0x0C,0x00,0x00,0x00,0x60,0x07,0xE0,
  0x00,0x08,0x00,0x84,0x00,0x60,0x00,0x00,
  0x00,0x18,0x00,0xE0,0x00,0x60,0x00,0x00,
  0x00,0x30,0x01,0xE0,0x00,0x60,0x00,0x00,
  0x00,0x20,0x01,0xC0,0x00,0x60,0x00,0x00,
  0x00,0x60,0x03,0x80,0x00,0x60,0x00,0x00,
  0x00,0x40,0x07,0x00,0x00,0x60,0x00,0x00,
  0x00,0xC0,0x06,0x00,0x00,0x60,0x00,0x00,
  0x01,0x80,0x0C,0x00,0x00,0x60,0x00,0x00,
  0x03,0x00,0x0C,0x00,0x00,0x60,0x00,0x00,
  0x07,0xFF,0xF8,0x00,0x00,0x60,0x00,0x00,
  0x03,0xF8,0x30,0x00,0x00,0x60,0x06,0x00,
  0x01,0x80,0x20,0x00,0x00,0x60,0x0F,0x00,
  0x00,0x00,0x60,0x07,0xFF,0xFF,0xFF,0x80,
  0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,
  0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,
  0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x10,0x00,0x00,0x80,0x00,0x0C,0x00,
  0x00,0x60,0x07,0x00,0xC0,0x00,0x1E,0x00,
  0x00,0xC1,0xF0,0x00,0xC0,0x00,0x1F,0x00,
  0x01,0xFF,0x80,0x00,0xC0,0x00,0x1C,0x00,
  0x00,0xFC,0x00,0x00,0xC0,0x00,0x1C,0x00,
  0x00,0xF0,0x00,0x00,0xC0,0x00,0x1C,0x00,
  0x00,0x40,0x00,0x00,0xC0,0x00,0x1C,0x00,
  0x00,0x00,0x00,0x00,0xC0,0x00,0x1C,0x00,
  0x00,0x00,0x00,0x00,0xC0,0x00,0x1C,0x00,
  0x00,0x00,0x00,0x00,0xC0,0x00,0x1C,0x00,
  0x00,0x00,0x00,0x00,0xC0,0x00,0x1C,0x00,
  0x00,0x00,0x00,0x20,0xC0,0x00,0x1C,0x00,
  0x00,0x00,0x03,0x00,0xC0,0x00,0x1C,0x00,
  0x00,0x00,0x38,0x00,0xC0,0x00,0x1C,0x00,
  0x00,0x01,0xE0,0x00,0xC0,0x00,0x1C,0x00,
  0x00,0x3F,0x00,0x00,0xC0,0x00,0x1C,0x00,
  0x03,0xF8,0x00,0x00,0xC0,0x00,0x1C,0x00,
  0x03,0xE0,0x00,0x00,0xFF,0xFF,0xFC,0x00,
  0x01,0x80,0x00,0x00,0xC0,0x00,0x1C,0x00,
  0x01,0x00,0x00,0x00,0xC0,0x00,0x1C,0x00,
  0x00,0x00,0x00,0x00,0xC0,0x00,0x1C,0x00,
  0x00,0x00,0x00,0x00,0xC0,0x00,0x1C,0x00,
  0x00,0x00,0x00,0x00,0xC0,0x00,0x18,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

char shu64S[]={
/* 以下是 '束' 的 64点阵宋体 字模，512 byte */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x03,0x80,0x00,0x00,0x00,
  0x00,0x00,0x00,0x03,0xC0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x03,0x80,0x00,0x00,0x00,
  0x00,0x00,0x00,0x03,0x80,0x00,0x00,0x00,
  0x00,0x00,0x00,0x03,0x80,0x00,0x00,0x00,
  0x00,0x00,0x00,0x03,0x80,0x00,0x01,0x00,
  0x00,0x00,0x00,0x03,0x80,0x00,0x03,0x80,
  0x00,0x00,0x00,0x03,0x80,0x00,0x07,0xC0,
  0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE0,
  0x00,0x00,0x00,0x03,0x80,0x00,0x00,0x00,
  0x00,0x00,0x00,0x03,0x80,0x00,0x00,0x00,
  0x00,0x00,0x00,0x03,0x80,0x00,0x00,0x00,
  0x00,0x00,0x00,0x03,0x80,0x00,0x00,0x00,
  0x00,0x00,0x00,0x03,0x80,0x00,0x00,0x00,
  0x00,0x00,0x00,0x03,0x80,0x00,0x00,0x00,
  0x00,0x00,0x00,0x03,0x80,0x00,0x40,0x00,
  0x00,0x0C,0x00,0x03,0x80,0x00,0xE0,0x00,
  0x00,0x0F,0x00,0x03,0x80,0x01,0xF0,0x00,
  0x00,0x07,0x00,0x03,0x80,0x00,0xE0,0x00,
  0x00,0x07,0x00,0x03,0x80,0x00,0xE0,0x00,
  0x00,0x07,0x00,0x03,0x80,0x00,0xE0,0x00,
  0x00,0x07,0x00,0x03,0x80,0x00,0xE0,0x00,
  0x00,0x07,0x00,0x03,0x80,0x00,0xE0,0x00,
  0x00,0x07,0x00,0x03,0x80,0x00,0xE0,0x00,
  0x00,0x07,0x00,0x03,0x80,0x00,0xE0,0x00,
  0x00,0x07,0x00,0x03,0x80,0x00,0xE0,0x00,
  0x00,0x07,0x00,0x03,0x80,0x00,0xE0,0x00,
  0x00,0x07,0x00,0x03,0x80,0x00,0xE0,0x00,
  0x00,0x07,0x00,0x03,0x80,0x00,0xE0,0x00,
  0x00,0x07,0x00,0x03,0x80,0x00,0xE0,0x00,
  0x00,0x07,0x00,0x03,0x80,0x00,0xE0,0x00,
  0x00,0x07,0x00,0x1F,0x90,0x00,0xE0,0x00,
  0x00,0x07,0x00,0x3F,0x80,0x00,0xE0,0x00,
  0x00,0x07,0x00,0x3F,0x88,0x00,0xE0,0x00,
  0x00,0x07,0x00,0x7B,0x88,0x00,0x80,0x00,
  0x00,0x0F,0x00,0x73,0x84,0x00,0x00,0x00,
  0x00,0x0C,0x00,0xE3,0x86,0x00,0x00,0x00,
  0x00,0x00,0x01,0xE3,0x82,0x00,0x00,0x00,
  0x00,0x00,0x01,0xC3,0x81,0x00,0x00,0x00,
  0x00,0x00,0x03,0x83,0x81,0x80,0x00,0x00,
  0x00,0x00,0x07,0x03,0x80,0xC0,0x00,0x00,
  0x00,0x00,0x0E,0x03,0x80,0x60,0x00,0x00,
  0x00,0x00,0x1C,0x03,0x80,0x70,0x00,0x00,
  0x00,0x00,0x18,0x03,0x80,0x38,0x00,0x00,
  0x00,0x00,0x30,0x03,0x80,0x1E,0x00,0x00,
  0x00,0x00,0x60,0x03,0x80,0x0F,0x00,0x00,
  0x00,0x00,0xC0,0x03,0x80,0x07,0xC0,0x00,
  0x00,0x03,0x80,0x03,0x80,0x03,0xF0,0x00,
  0x00,0x06,0x00,0x03,0x80,0x01,0xFC,0x00,
  0x00,0x0C,0x00,0x03,0x80,0x00,0x7F,0x80,
  0x00,0x18,0x00,0x03,0x80,0x00,0x3F,0xC0,
  0x00,0x60,0x00,0x03,0x80,0x00,0x0F,0x00,
  0x00,0x80,0x00,0x03,0x80,0x00,0x06,0x00,
  0x00,0x00,0x00,0x03,0x80,0x00,0x00,0x00,
  0x00,0x00,0x00,0x03,0x80,0x00,0x00,0x00,
  0x00,0x00,0x00,0x03,0x80,0x00,0x00,0x00,
  0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

void showNode(BinTree bt,DataType data,char key)
{
	BinTree	p;
	TRAVERSE_SIGN=0;
	BTFindNode(bt,&p,data,key,DrawFindNode);
}
void showLeaf(BinTree bt)
{
	int i,j,k;
	BinTree p[16];
	k=BTFindLeaf(bt,p);
	for(i=0;i<k;i++)
	{	
		j=0;
		while(p[i]!=BTXY[j].bt&&j<31)j++;
		SignFilledCircle(BTXY[j].x,BTXY[j].y,BTXY[j].bt->data);
		Delay2s();
	}
	
}
void showTraverse(BinTree bt,char key)
{
	
	BTreeToArr(bt,BTXY);
	GetBTArrXY(BTXY);
	TRAVERSE_SIGN=0;
	if(key==PRE)
	{	
		
		PreOrderTraverse(bt,DrawBT);
	}else if(key==IN)
	{
		
		InOrderTraverse(bt,DrawBT);
	}else if(key==POST)
	{
		
		PostOrderTraverse(bt,DrawBT);
	}
		
	
}

void DrawBT(BinTree bt)
{
	int i=0;
	
	
	while(bt!=BTXY[i].bt&&i<31)i++;
	if(TRAVERSE_SIGN==0)
	{
		STATIC_X=BTXY[i].x;
		STATIC_Y=BTXY[i].y;
		TRAVERSE_SIGN++;
	}
	
	SignFilledCircle(BTXY[i].x,BTXY[i].y,BTXY[i].bt->data);
	CLine(STATIC_X,STATIC_Y,BTXY[i].x,BTXY[i].y,RED);
	Delay2s();
	STATIC_X=BTXY[i].x;
	STATIC_Y=BTXY[i].y;
}

void DrawFindNode(BinTree bt)
{
	int i=0;
	
	cleardevice();
	ShowTreeL(BTXY[0].bt);
	ShowTreeR();
	while(bt!=BTXY[i].bt&&i<31)i++;
	
	
	SignFilledCircle(BTXY[i].x,BTXY[i].y,BTXY[i].bt->data);
	
	Delay2s();
	
}
/*
函数名：
功能：标记圆
参数：

*/
void  SignFilledCircle(int x,int y,DataType cc)
{
	char ch[2]={0};
	ch[0]=cc;
	setfillstyle(1,RED);
	setcolor(RED);
	circle(x,y,10);
	floodfill(x, y, RED); 
	
	setcolor(YELLOW);
	outtextxy(x-1,y-5,ch);
	
}
/*
函数名：
功能：画圆
参数：

*/
void  FilledCircle(int x,int y,DataType cc)
{
	char ch[2]={0};
	ch[0]=cc;
	setfillstyle(1,GREEN);
	setcolor(GREEN);
	circle(x,y,8);
	
	floodfill(x, y, GREEN);
	
	setcolor(YELLOW);
	outtextxy(x-1,y-5,ch);
	
	
}
/*
函数名：
功能：画线
参数：

*/
void CLine(int x1, int y1, int x2, int y2,int color)
{
	setcolor(color);
	line(x1,y1,x2,y2);
}

/*
函数名：
功能：
参数：

*/
void ShowTreeL(BinTree bt)
{
	
	int i,j,old_rx,old_ry,sum=0;
	
	
	MAX_X=getmaxx(),MAX_Y=getmaxy();
	BTreeToArr(bt,BTXY);
	GetBTArrXY(BTXY);
	if(BTXY[0].bt==0)
	{
		closegraph();
		setcolor(RED);
		outtextxy(getmaxx()/4,getmaxy()/4,"Empty Btree!");
		if(!getch())getch();
		return;
	}
	/*两个循环是建模时是二维数组，但实践中二维数组错误，于是用了累加 等算法来查找*/
	for(i=0;i<5;i++)
	{
		
		for(j=0;j<pow(2,i);j++)
		{
			
			if(BTXY[sum].bt->data&&i>0)
			{	
				old_ry=(i-1)*MAX_Y/7+30;
				old_rx=pow(-1,j)*MAX_X/pow(2,i+1)+BTXY[sum].x;
				CLine(old_rx,old_ry+10,BTXY[sum].x,BTXY[sum].y,WHITE);
				
			}
			sum++;		
		}
	}
}
void ShowTreeR()
{
	
	int i,j,old_rx,old_ry,sum=0;
	if(BTXY[0].bt==0)
	{
		closegraph();
		setcolor(RED);
		outtextxy(getmaxx()/4,getmaxy()/4,"Empty Btree!");
		getch();
		return;
	}
	/*两个循环是建模时是二维数组，但实践中二维数组错误，于是用了累加 等算法来查找*/
	
			
		
	for(i=0;i<5;i++)
	{
		
		for(j=0;j<pow(2,i);j++)
		{	
			 if(i==0)
			{
				FilledCircle(BTXY[sum].x,BTXY[sum].y,BTXY[sum].bt->data);
			}else if(BTXY[sum].bt->data)
			{	
				
				FilledCircle(BTXY[sum].x,BTXY[sum].y,BTXY[sum].bt->data);
			}
			sum++;		
		}
			
		
		
	}
}
/*
函数名：
功能：给结构体确定xy值
参数：

*/
void GetBTArrXY(BTreeXY BTXY[])
{
	int i,j;
	for(i=0;i<5;i++)
	{
			for(j=0;j<pow(2,i);j++)
			{
				if(i==0&&BTXY[0].bt!=0)
				{
					BTXY[0].x=(2*j+1)*MAX_X/pow(2,i+1);
					BTXY[0].y=(i)*MAX_Y/7+30;
					
				}else if(BTXY[FunSumPow(i-1)+j].bt!=0)
				{
					BTXY[FunSumPow(i-1)+j].x=(2*j+1)*MAX_X/pow(2,i+1);
					BTXY[FunSumPow(i-1)+j].y=(i)*MAX_Y/7+30;
				}
				
			}
		
		
	}
}
/*
函数名：
功能：
参数：

*/
void BTreeToArr(BinTree bt,BTreeXY BTXY[])
{
	int i,j,k;
	BinTree newp;
	BTXY[0].bt=bt;
	for(i=0;i<5;i++)
	{
		if(i==0)
		{
			BTXY[0].bt=bt;
		}else if(i==1)
		{
			BTXY[1].bt=BTXY[0].bt->lchild;
			BTXY[2].bt=BTXY[0].bt->rchild;
		}else
		{	
			k=0;
			j=0;
			while(j<pow(2,i)&&k<pow(2,i-1))
			{
				if(BTXY[FunSumPow(i-2)+k].bt==0)
				{
					BTXY[FunSumPow(i-1)+j].bt=0;
					j++;
					BTXY[FunSumPow(i-1)+j].bt=0;
					j++;
					k++;
				}else 
				{
					newp=BTXY[FunSumPow(i-2)+k].bt;
					BTXY[FunSumPow(i-1)+j].bt=newp->lchild;
					j++;
					BTXY[FunSumPow(i-1)+j].bt=newp->rchild;
					j++;
					k++;
				}
				
			}
		}
		
	}
}
int FunSumPow(int i)
{
	if(i==0)
	{
		return 1;
	}
	return pow(2,i)+FunSumPow(i-1);
}
void Delay2s()
{
	clock_t start=clock();
	while((clock()-start)/CLK_TCK<0.4);
}
#endif